@{
    ViewData["Title"] = "Razor";
}

<div class="text-center">
    <h2 class="display-4">Інверсия управления </h2>

</div>
<p>
    <b>IoC</b> </br>Inversion of Control - Інверсия управління життевим циклом
    об'єктів. Патерн проєктування відповідно до якого задачі створення.
    використання та знищення об'єктів перекладаються на спеціальний модуль (Інжектор, контейнер сервісів).
    Замість інструкції <code>new Servise()</code>  у кожному контролері, який потребує обєкту , даний об'єкт реєструється один раз , а споживачі (контролери)
    звертаються до цього об'єкту за допомогою інжекції. Можна порівняти з глобальними об'єктами.
</p>
<p>
    <b>Не плутати </b><br/>
    <b>IoC </b> - Inversion of Control - патерн<br />
    <b> DIP</b> - Dependency Inversion Principle (SOLID) - принцип <br />
    <b>DI</b> - Dependency Injection - спосіб передачи посилань на сервіси<br />
</p>
<p>
    IoC впроваджено в ASP  "з коробки" <br />
    Процес інверсії можна описати наступними кроками<br />

</p>
<ol>
    <li>
        (Одноразово) - створюємо дерикторію "Services"
    </li>
    <li>
        Визначаємося з сервісом, що знадобиться у різних "місцях"
        .Наприклад це сервіс часу, що повертає час timestamp
    </li>
    <li>
        Створюємо директориюдля даної служби у загальншй дерикторії

    </li>
    <li>
        Утворюємо інтерфейс у дерикторії, утворюємо клас-імплементацію інтерфейсу
    </li>
    <li>
      Реєструємо сервіс у Program.cs
    </li>
    <li>
        @ViewData["timestamp"] / @ViewData["timestampCode"]
    </li>
    <li>
        За потреби змінити спосіб роботи сервісу користуємося принципом ОСР 
    </li>
</ol>
